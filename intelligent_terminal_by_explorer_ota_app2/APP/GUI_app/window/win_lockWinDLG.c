/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.32                          *
*        Compiled Oct  8 2015, 11:59:02                              *
*        (c) 2015 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/

// USER START (Optionally insert additional includes)
// USER END

#include "DIALOG.h"
#include "SCROLLBAR.h"
#include "SCROLLBAR_Private.h"
#include "GUI_app/gui_thread.h"
#include "config.h"

/*********************************************************************
*
*       user config
*
**********************************************************************
*/
//锁定画面尺寸定义
#define LOCK_SCREEN_X         0
#define LOCK_SCREEN_Y         STATUS_BAR_HEIGHT
#define LOCK_SCREEN_XSIZE     (LCD_xsize-LOCK_SCREEN_X)
#define LOCK_SCREEN_YSIZE     (LCD_ysize-LOCK_SCREEN_Y)
//在状态栏的基础上偏移
#define LOCK_BAR_Y0_RATE      0.75f   //解锁条在LCD屏幕的比例位置
#define LOCK_BAR_Y0     (int)(LCD_ysize*LOCK_BAR_Y0_RATE-STATUS_BAR_HEIGHT)    //解锁条的Y方向起点,始终保证在
  
#define TEXT_BAR_Y0     50             //文本框的左上角起点，相对于LOCK_SCREEN为0
#define TEXT_BAR_YSIZE  40
#define SMILE_ICON_Y0   (LOCK_SCREEN_YSIZE)/2     //笑脸图标的中心点Y方向
//锁定界面参数
#define VALUE_NO_TRIGGER  -1      //滑条按钮没有触发下的返回减少的值
#define LOCK_BAR_REFRESH_RATE 30  //解锁条刷新率
#define TIME_REFRESH_RATE 1000    //时间显示刷新率
//解锁条外观调整
#define LOCK_BAR_LIMIT  15        //解锁条超出限制，由于不要左右按钮，需要起点和终点超出界限
#define LOCK_BAR_WIDTH  40        //解锁条的宽度，上下高度
#define SLIDE_STRIP_VALUE 40      //滑条最大值，决定滑块大小
#define LOCK_BAR_OSIZE      1     //解锁条外框尺寸
#define LOCK_BAR_ISIZE      1     //解锁条内框尺寸
#define LOCK_BAR_RSIZE      3     //解锁条中所有圆角尺寸
#define SLIDE_OSIZE           3   //滑块在解锁条中的间距
#define DY_SLIDE_WIDTH        20   //动态滑条宽度
#define DY_SLIDE_OSIZE        3   //动态滑条尺寸
#define DY_SLIDE_SPEED        1   //动态速度

//时间外观调整
#define TIME_Y_OFFSET         100  //时间的垂直位置，越大越往上

#define VIEW_DEBUG            0
/*********************************************************************
*
*       variables
*
**********************************************************************
*/
static float dy_slider_value=0;           //动态滑块的移动值

extern WM_HWIN _hLastFrame[WIN_MAX_NUM];;	
extern GUI_CONST_STORAGE GUI_BITMAP bmwallpaper_ios15_1;        //失真的IOS壁纸
extern GUI_CONST_STORAGE GUI_BITMAP bmwallpaper_ios15_2;        //全彩的IOS壁纸
extern GUI_CONST_STORAGE GUI_BITMAP bmwallpaper_smile;          //失真的笑脸壁纸
extern GUI_CONST_STORAGE GUI_BITMAP bmicon_unlock_arrow;
extern GUI_CONST_STORAGE GUI_BITMAP bmicon_smile;
extern GUI_CONST_STORAGE GUI_FONT GUI_Fontfont_songti_38_bold_ascii_unicode;

extern RTC_TimeTypeDef RTC_TimeStruct;
extern RTC_DateTypeDef RTC_DateStruct;

extern void init_mainpage(void);
WM_HWIN Createlockwin(void);
WM_HWIN Createwin_mainpage(void);
WM_HWIN lock_handle;

GUI_MEMDEV_Handle icon_arrow_handle;
/*********************************************************************
*
*       Defines
*
**********************************************************************
*/
#define ID_WINDOW_0       (GUI_ID_USER + 0x00)
#define ID_SCROLLBAR_0    (GUI_ID_USER + 0x01)
#define ID_TEXT_0         (GUI_ID_USER + 0x02)

#define TIMER_0           0
#define TIMER_1           1
// USER START (Optionally insert additional defines)
// USER END

/*********************************************************************
*
*       Static code
*
**********************************************************************
*/

#if(VIEW_DEBUG==0)
static signed short but_lcd_xoffset;
static signed short but_lcd_yoffset;
static int SCROLLBAR_0_DrawSkin(const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo) {
  static int SCROLLBAR0_state=0;
  static int UNLOCK_BAR_x0=0,UNLOCK_BAR_y0=0,UNLOCK_BAR_x1=0,UNLOCK_BAR_y1=0;
  static unsigned char init=0;
  
  SCROLLBAR_SKINFLEX_INFO * pSkinInfo;
  pSkinInfo = (SCROLLBAR_SKINFLEX_INFO *)pDrawItemInfo->p;
  char text[]="    slide to unlock";
  GUI_RECT pRect;
  int offset;
  int temp;
  
  switch (pDrawItemInfo->Cmd) {
    case WIDGET_ITEM_CREATE:            //创建控件后立即发送
      return SCROLLBAR_DrawSkinFlex(pDrawItemInfo);
    case WIDGET_ITEM_DRAW_BUTTON_L:     //皮肤设置函数将绘制左侧按钮
      if( but_lcd_yoffset==0){
//        offset=pDrawItemInfo->x1-pDrawItemInfo->x0;
        temp=WM_GetWindowOrgX(pDrawItemInfo->hWin);
        but_lcd_xoffset=temp+LOCK_BAR_OSIZE+LOCK_BAR_ISIZE+SLIDE_OSIZE-2;
        but_lcd_yoffset=WM_GetWindowOrgY(pDrawItemInfo->hWin)+LOCK_BAR_OSIZE+LOCK_BAR_ISIZE+SLIDE_OSIZE-5;
//        xprintf("xoffset:%d yoffset:%d \r\n",but_lcd_xoffset,but_lcd_yoffset);
      }
      //不绘制
      return 0;
    case WIDGET_ITEM_DRAW_BUTTON_R:       //皮肤设置函数将绘制右侧按钮
      //不绘制
      return 0;
    case WIDGET_ITEM_DRAW_OVERLAP:      //皮肤设置函数将绘制重叠区域。
      return SCROLLBAR_DrawSkinFlex(pDrawItemInfo);
    
    case WIDGET_ITEM_DRAW_SHAFT_L:      //皮肤设置函数将绘制轴的左侧部分
//      xprintf("SHAFT_L x0:%d y0:%d x1:%d y1:%d \r\n",pDrawItemInfo->x0,pDrawItemInfo->y0,pDrawItemInfo->x1,pDrawItemInfo->y1);
      //绘制外框,外框使用圆角矩形，填充后，下面又覆盖中间区域
      UNLOCK_BAR_x0=pDrawItemInfo->x0;
      UNLOCK_BAR_y0=pDrawItemInfo->y0;
      if(UNLOCK_BAR_x1){
        GUI_SetColor(GUI_GRAY);     //指定外框颜色
        //绘制外框区域
        GUI_FillRoundedRect(UNLOCK_BAR_x0,UNLOCK_BAR_y0,UNLOCK_BAR_x1,UNLOCK_BAR_y1,LOCK_BAR_RSIZE);
        
        //绘制内框，虽然为填充，后面覆盖掉
        offset=LOCK_BAR_OSIZE;
        GUI_DrawGradientRoundedV(UNLOCK_BAR_x0+offset,      //根据外框尺寸偏移
            UNLOCK_BAR_y0+offset,
            UNLOCK_BAR_x1-offset,
            UNLOCK_BAR_y1-offset,
            LOCK_BAR_RSIZE,GUI_DARKGRAY,GUI_LIGHTGRAY);                     //滑条底部渐变为白色
        
        //绘制滑条
        offset=LOCK_BAR_OSIZE+LOCK_BAR_ISIZE;
        GUI_DrawGradientRoundedV(UNLOCK_BAR_x0+offset,
            UNLOCK_BAR_y0+offset,
            UNLOCK_BAR_x1-offset,                 
            UNLOCK_BAR_y1-offset,                 
            LOCK_BAR_RSIZE,GUI_BLACK,GUI_DARKGRAY);
   
        //绘制动态滑条  
        offset=LOCK_BAR_OSIZE+LOCK_BAR_ISIZE+DY_SLIDE_OSIZE;
        pRect.x0=dy_slider_value+UNLOCK_BAR_x0+offset;
        pRect.x1=pRect.x0+DY_SLIDE_WIDTH;
        pRect.y0=UNLOCK_BAR_y0+offset;
        pRect.y1=UNLOCK_BAR_y1-offset;
        if(dy_slider_value<=DY_SLIDE_WIDTH && init==0){         //头部逐渐出现
          pRect.x0=UNLOCK_BAR_x0+offset;
          pRect.x1=UNLOCK_BAR_x0+offset+dy_slider_value;
          if(dy_slider_value==DY_SLIDE_WIDTH){
            init=1;                 //头部出现效果完成
            dy_slider_value=0;      //正常显示开始
          }
        }
        if((pRect.x1)>=UNLOCK_BAR_x1-offset){                   //尾部逐渐消失
          pRect.x1=UNLOCK_BAR_x1-offset;
          if(pRect.x0>=pRect.x1){
            init=0;
            dy_slider_value=0;
          }  
        }   
        // 绘制动态滑条，使用透明效果
        GUI_DrawGradientRoundedH(pRect.x0,pRect.y0,pRect.x1,pRect.y1,                 
        LOCK_BAR_RSIZE,GUI_MAKE_COLOR((0xaauL << 24) | GUI_DARKGRAY),GUI_MAKE_COLOR((0xaauL << 24) | GUI_WHITE));     //制作混合色   
        
        //显示字体
        pRect.x0=UNLOCK_BAR_x0;
        pRect.y0=UNLOCK_BAR_y0;
        pRect.x1=UNLOCK_BAR_x1;
        pRect.y1=UNLOCK_BAR_y1;
        GUI_SetColor(GUI_GRAY);                           //指定外框颜色
        GUI_SetFont(GUI_FONT_8X16_ASCII);
        GUI_SetTextMode(GUI_TM_TRANS|GUI_TM_XOR);        //设置为显示透明文本
        GUI_DispStringInRectEx(text,&pRect,GUI_TA_VCENTER|GUI_TA_HCENTER,sizeof(text),GUI_ROTATE_0); 
      }
      return 0;
    
    case WIDGET_ITEM_DRAW_SHAFT_R:      //皮肤设置函数将绘制轴的右侧部分。
      UNLOCK_BAR_x1=pDrawItemInfo->x1;
      UNLOCK_BAR_y1=pDrawItemInfo->y1;
      return 0;
    
    case WIDGET_ITEM_DRAW_THUMB:          //皮肤设置函数将绘制缩略图
//      xprintf("THUMB x0:%d y0:%d x1:%d y1:%d \r\n",pDrawItemInfo->x0,pDrawItemInfo->y0,pDrawItemInfo->x1,pDrawItemInfo->y1);
      if(SCROLLBAR0_state!=pSkinInfo->State){           //保存中间按钮状态到用户数据
        SCROLLBAR0_state=pSkinInfo->State;
        SCROLLBAR_SetUserData(pDrawItemInfo->hWin,&SCROLLBAR0_state,sizeof(SCROLLBAR0_state));
      }
      //绘制滑块
      GUI_DrawGradientRoundedV(pDrawItemInfo->x0+SLIDE_OSIZE,
          pDrawItemInfo->y0+SLIDE_OSIZE,
          pDrawItemInfo->x1-SLIDE_OSIZE,
          pDrawItemInfo->y1-SLIDE_OSIZE,
          LOCK_BAR_RSIZE,GUI_WHITE,GUI_LIGHTGRAY);                     //滑条底部渐变为白色    

      //绘制箭头
//      GUI_DrawBitmapEx(&bmicon_unlock_arrow, pDrawItemInfo->x0+(pDrawItemInfo->x1-pDrawItemInfo->x0)/2+2, 
//      (pDrawItemInfo->y1-pDrawItemInfo->y0)/2,bmicon_unlock_arrow.XSize/2,bmicon_unlock_arrow.YSize/2,500,500);
      GUI_MEMDEV_WriteAt(icon_arrow_handle,
      but_lcd_xoffset + ((pDrawItemInfo->x1-pDrawItemInfo->x0)-bmicon_unlock_arrow.XSize)/2+pDrawItemInfo->x0,
      but_lcd_yoffset + ((pDrawItemInfo->y1-pDrawItemInfo->y0)-bmicon_unlock_arrow.YSize)/2+pDrawItemInfo->y0);   
      return 0;
      
    case WIDGET_ITEM_GET_BUTTONSIZE:
      return (pSkinInfo->IsVertical) ?
      pDrawItemInfo->x1 - pDrawItemInfo->x0 + 1 :
      pDrawItemInfo->y1 - pDrawItemInfo->y0 + 1;
      
    default:                            //所有其他类型将以默认皮肤执行
      return SCROLLBAR_DrawSkinFlex(pDrawItemInfo);
  }
}
#endif
/*********************************************************************
*
*       _cbDialog
*/
#if(VIEW_DEBUG==1)
static void debug_view_region(void)
{
  //绘制窗口区域  
  GUI_SetColor(GUI_RED);        
  GUI_FillCircle(2,2,2);
  
  GUI_SetColor(GUI_RED);        
  GUI_DrawRect(LOCK_SCREEN_X-LOCK_BAR_LIMIT, LOCK_BAR_Y0,LOCK_SCREEN_X-LOCK_BAR_LIMIT+LOCK_SCREEN_XSIZE+LOCK_BAR_LIMIT*2,
    LOCK_BAR_Y0+(int)LOCK_SCREEN_YSIZE*0.15f);
  
  //绘制文本区域   
  GUI_SetColor(GUI_WHITE);        
  GUI_DrawRect(LOCK_SCREEN_X, TEXT_BAR_Y0, 
    LOCK_SCREEN_X+LOCK_SCREEN_XSIZE, 
    TEXT_BAR_Y0+TEXT_BAR_YSIZE);
}
#endif

static void _cbDialog(WM_MESSAGE * pMsg) {
  WM_HWIN hItem;
  int SCROLLBAR0_state=0;
  int SCROLLBAR0_value=0;
  char time_id;
  char tbuf[40];

  // USER START (Optionally insert additional variables)
  // USER END
  switch (pMsg->MsgId) {
  case WM_CREATE : 
#if(VIEW_DEBUG==0)
    //创建解锁条
    hItem=SCROLLBAR_CreateUser(LOCK_SCREEN_X-LOCK_BAR_LIMIT, LOCK_BAR_Y0,LOCK_SCREEN_XSIZE+LOCK_BAR_LIMIT*2,(int)LOCK_SCREEN_YSIZE*0.15f,
        pMsg->hWin,WM_CF_SHOW, SCROLLBAR_CF_FOCUSSABLE ,ID_SCROLLBAR_0, sizeof(SCROLLBAR0_state));
    SCROLLBAR_SetNumItems(hItem, SLIDE_STRIP_VALUE);
    SCROLLBAR_SetWidth(hItem,LOCK_BAR_WIDTH);
    SCROLLBAR_SetSkin(hItem,SCROLLBAR_0_DrawSkin);        //设置控件的皮肤回调
    WM_SetFocus(hItem);
   
    //创建文本框，显示时间
    sprintf((char*)tbuf,"%02d:%02d",RTC_TimeStruct.RTC_Hours,RTC_TimeStruct.RTC_Minutes); 
    hItem=TEXT_CreateEx(LOCK_SCREEN_X, TEXT_BAR_Y0,LOCK_SCREEN_XSIZE, TEXT_BAR_YSIZE,
      pMsg->hWin,WM_CF_SHOW,TEXT_CF_HCENTER|TEXT_CF_TOP, ID_TEXT_0,tbuf);
    TEXT_SetFont(hItem,&GUI_Fontfont_songti_38_bold_ascii_unicode);
    TEXT_SetBkColor(hItem, GUI_INVALID_COLOR);            //使用背景颜色，透明字体
    
    /*创建内存设备*/    
    //内存设备区域的左上角起点X坐标  ,由icon_x计算        
    icon_arrow_handle=GUI_MEMDEV_CreateFixed(100,100,
    bmicon_unlock_arrow.XSize,bmicon_unlock_arrow.YSize,
    GUI_MEMDEV_HASTRANS, GUI_MEMDEV_APILIST_16, GUICC_M565);
    //绘制位图
    GUI_MEMDEV_Select(icon_arrow_handle);
    GUI_DrawBitmap(&bmicon_unlock_arrow, 100,100);     
    
    //重新指定LCD输出
    GUI_MEMDEV_Select(0);
#endif    
    break; 

  case WM_PAINT:
    //绘制图标区域
    GUI_SetBkColor(0x00FFC880);         //自定义调色
    GUI_Clear();
    GUI_DrawBitmap(&bmicon_smile, 
    LOCK_SCREEN_XSIZE/2-bmicon_smile.XSize/2, 
    SMILE_ICON_Y0 - bmicon_smile.YSize/2);        
#if(VIEW_DEBUG==1)
    debug_view_region();
#endif 
  break;
 
  case WM_TIMER:
    time_id=WM_GetTimerId(pMsg->Data.v);
    switch(time_id){
      case TIMER_0:           //解锁条的刷新率
        WM_RestartTimer(pMsg->Data.v, LOCK_BAR_REFRESH_RATE);
        //高刷新率刷新解锁条
        //如果滑条按钮没有被按，自动回退
        hItem=WM_GetDialogItem(pMsg->hWin, ID_SCROLLBAR_0);
        WM_InvalidateWindow(hItem);                                                   //单独刷新解锁条
        SCROLLBAR_GetUserData(hItem,&SCROLLBAR0_state,sizeof(SCROLLBAR0_state));      //可以使用全局变量
        if(!(SCROLLBAR0_state & PRESSED_STATE_THUMB)){
          SCROLLBAR_AddValue(hItem,VALUE_NO_TRIGGER);     //中间按钮返回
        }
        dy_slider_value=dy_slider_value+DY_SLIDE_SPEED;
        SCROLLBAR0_value=SCROLLBAR_GetValue(hItem);
        //xprintf("SCROLLBAR0_value:%d\r\n",SCROLLBAR0_value);
        if(SCROLLBAR0_value==(SLIDE_STRIP_VALUE-10)){       //解锁屏幕
          detete_last_win();
          Createwin_mainpage();
        }
        break;
        
      case TIMER_1:                 //时间的刷新率
        sprintf((char*)tbuf,"%02d:%02d",RTC_TimeStruct.RTC_Hours,RTC_TimeStruct.RTC_Minutes); 
        hItem=WM_GetDialogItem(pMsg->hWin, ID_TEXT_0);
        TEXT_SetText(hItem,tbuf);
        WM_RestartTimer(pMsg->Data.v, TIME_REFRESH_RATE);
        break;
    }
    break; 
    
  case WM_DELETE:
    GUI_MEMDEV_Delete(icon_arrow_handle);
    break;
  
  default:
    WM_DefaultProc(pMsg);
    break;
  }
}

/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
/*********************************************************************
*
*       Createunlockwin
*/
WM_HWIN Createlockwin(void) {
  WM_HWIN win[WIN_MAX_NUM]={0};
  win[0]=WM_CreateWindowAsChild(LOCK_SCREEN_X, LOCK_SCREEN_Y, LOCK_SCREEN_XSIZE, LOCK_SCREEN_YSIZE,
  WM_HBKWIN, WM_CF_SHOW, _cbDialog, 0);
  lock_handle=win[0];
  
  WM_CreateTimer(win[0], TIMER_0, LOCK_BAR_REFRESH_RATE, 0);
  WM_CreateTimer(win[0], TIMER_1, TIME_REFRESH_RATE, 0);
  switch_win(win,LOCK_WIN_ID);
  return win[0];
}

// USER START (Optionally insert additional public code)
// USER END

/*************************** End of file ****************************/
