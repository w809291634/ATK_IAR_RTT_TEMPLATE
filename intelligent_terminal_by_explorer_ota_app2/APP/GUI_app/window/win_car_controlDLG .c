/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.32                          *
*        Compiled Oct  8 2015, 11:59:02                              *
*        (c) 2015 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/

// USER START (Optionally insert additional includes)
// USER END

#include "DIALOG.h"
#include "GUI_app/gui_thread.h"
#include "GUI.h"
#include "LCD/lcd.h"
#include "config.h"
#include <math.h>
#include <stdlib.h> 

/*********************************************************************
*
*       user config
*
**********************************************************************
*/
#define CAR_CONTROL_SCREEN_X         0
#define CAR_CONTROL_SCREEN_Y         STATUS_BAR_HEIGHT               
#define CAR_CONTROL_SCREEN_XSIZE     (LCD_xsize-CAR_CONTROL_SCREEN_X)
#define CAR_CONTROL_SCREEN_YSIZE     (int)((LCD_ysize-CAR_CONTROL_SCREEN_Y))

#define CAR_CONTROL_SCREEN_REFRESH_RATE 20  	//主页 ICON_BAR 更新率

#define CAR_CONTROL_BACK_BUTTON_XSIZE  60
#define CAR_CONTROL_BACK_BUTTON_YSIZE  30
#define CAR_CONTROL_BACK_BUTTON_X  (LCD_xsize-CAR_CONTROL_BACK_BUTTON_XSIZE-10)
#define CAR_CONTROL_BACK_BUTTON_Y  10
#define SCREEN_BACK_FUN    Createwin_mainpage       //界面返回时创建的窗口回调函数

#define SCREEN_INTRODUCE_TEXT  "Control the car up, down, left and right"
#define CAR_CONTROL_SCR_TEXT_X        10
#define CAR_CONTROL_SCR_TEXT_Y        (CAR_CONTROL_BACK_BUTTON_Y+5+CAR_CONTROL_BACK_BUTTON_YSIZE)
#define CAR_CONTROL_SCR_TEXT_XSIZE    (LCD_xsize-10)
#define CAR_CONTROL_SCR_TEXT_YSIZE    30

#define RADIUS_POS_RATE               0.65f
#define CAR_ROCKER_INIT_POS_X         (LCD_xsize/2)
#define CAR_ROCKER_INIT_POS_Y         (unsigned int)(CAR_CONTROL_SCREEN_YSIZE*RADIUS_POS_RATE)
#define CAR_ROCKER_RADIUS             15
#define CAR_CIRCULAR_RADIUS           (unsigned int)(CAR_CONTROL_SCREEN_YSIZE*(1-RADIUS_POS_RATE)-30)
/*********************************************************************
*
*       variables
*
**********************************************************************
*/
extern WM_HWIN Createwin_mainpage(void);
unsigned int car_circular_center[2],car_circular_radius;
unsigned int car_rocker_center[2],car_rocker_radius;
static GUI_MEMDEV_Handle mem_handle;

volatile signed int car_rocker_offset_x=0;    // 摇杆X方向的移动量
volatile signed int car_rocker_offset_y=0;    // 摇杆Y方向的移动量
unsigned int car_rocker_offset_max=100;  // 摇杆XY方向的最大移动量
static unsigned char flag;          //位0：存放摇杆标志  位1：刚进入界面标志  位2：有效触摸
/*********************************************************************
*
*       Defines
*
**********************************************************************
*/
#define ID_WINDOW_0      (GUI_ID_USER + 0x00)
#define ID_TEXT_0        (GUI_ID_USER + 0x01)
#define ID_TEXT_1        (GUI_ID_USER + 0x02)
#define ID_BUTTON_0      (GUI_ID_USER + 0x03)   

#define TIMER_0           0
#define TIMER_1           1

static unsigned int dist( unsigned int x1, unsigned int y1, unsigned int x2, unsigned int y2 )
{
  unsigned int dis1=abs((int)(x1-x2));
  unsigned int dis2=abs((int)(y1-y2));
  return sqrt(dis1*dis1+dis2*dis2);
}

static double radian(unsigned int x1, unsigned int y1, unsigned int x2, unsigned int y2)
{
  double x=(double)((signed int)(x1-x2));
  double y=(double)((signed int)(y1-y2));
  return atan2(y,x);
}

static void init_page_parameter(void){
  car_rocker_offset_x=0;
  car_rocker_offset_y=0;
  flag=0;
}

/*********************************************************************
*
*       _cbDialog
*/
static void _cbDialog(WM_MESSAGE * pMsg) {
  WM_HWIN hItem;
  GUI_PID_STATE  pState; 
  int     NCode;
  int     Id;
  double rad;
  
  switch (pMsg->MsgId) {
  case WM_CREATE:
    // 初始化位置变量
    car_circular_center[0]=CAR_ROCKER_INIT_POS_X;
    car_circular_center[1]=CAR_ROCKER_INIT_POS_Y;
    memcpy(car_rocker_center,car_circular_center,sizeof(car_rocker_center));
    car_circular_radius=CAR_CIRCULAR_RADIUS;
    car_rocker_radius=CAR_ROCKER_RADIUS;
    car_rocker_offset_max=car_circular_radius-car_rocker_radius;
  
    //
    //ID_TEXT_0
    //
    hItem=TEXT_CreateEx(CAR_CONTROL_SCR_TEXT_X, CAR_CONTROL_SCR_TEXT_Y,CAR_CONTROL_SCR_TEXT_XSIZE, CAR_CONTROL_SCR_TEXT_YSIZE,
      pMsg->hWin,WM_CF_SHOW,TEXT_CF_VCENTER|GUI_TA_HCENTER, ID_TEXT_0,SCREEN_INTRODUCE_TEXT);
  
    TEXT_SetFont(hItem,GUI_FONT_8X12_ASCII);
    TEXT_SetBkColor(hItem, GUI_INVALID_COLOR);            //使用背景颜色，透明字体
    TEXT_SetTextColor(hItem,GUI_BLACK);
    TEXT_SetWrapMode(hItem, GUI_WRAPMODE_WORD);
  
    // 创建返回按钮
    hItem = BUTTON_CreateEx(CAR_CONTROL_BACK_BUTTON_X,CAR_CONTROL_BACK_BUTTON_Y
          ,CAR_CONTROL_BACK_BUTTON_XSIZE,CAR_CONTROL_BACK_BUTTON_YSIZE,pMsg->hWin,WM_CF_SHOW,0,ID_BUTTON_0);
    WM_SetFocus(hItem);
    WM_SetStayOnTop(hItem,1);                             //按钮窗口始终在最上面
    BUTTON_SetFont(hItem, GUI_FONT_8X12_ASCII);
    BUTTON_SetText(hItem, "Back");
  
    /*创建内存设备*/    
    //内存设备区域的左上角起点X坐标  ,由icon_x计算        
    mem_handle=GUI_MEMDEV_CreateFixed(car_rocker_center[0], car_rocker_center[1],
    car_rocker_radius*2+1, car_rocker_radius*2+1,
    GUI_MEMDEV_HASTRANS, GUI_MEMDEV_APILIST_16, GUICC_M565);
    //绘制位图
    GUI_MEMDEV_Select(mem_handle);
    GUI_SetColor(GUI_BLACK); 
    GUI_FillCircle(car_rocker_center[0]+car_rocker_radius, car_rocker_center[1]+car_rocker_radius, car_rocker_radius);
    
    // 还原回来LCD显示
    GUI_MEMDEV_Select(0);
    break;

  case WM_NOTIFY_PARENT:
    Id    = WM_GetId(pMsg->hWinSrc);
    NCode = pMsg->Data.v;
    switch(Id) {
    case ID_BUTTON_0: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
//        WM_DeleteWindow(pMsg->hWin);
        detete_last_win();
        SCREEN_BACK_FUN();
        break;
      case WM_NOTIFICATION_RELEASED:
        break;
      }
      break;
    }
    break;

  case WM_PAINT:
    //
    GUI_SetBkColor(GUI_WHITE);         
    GUI_Clear();
    GUI_SetColor(GUI_BLACK); 
    GUI_DrawCircle(car_circular_center[0], car_circular_center[1], car_circular_radius);
  
    // 绘制摇杆
    GUI_MEMDEV_WriteAt(mem_handle,
    car_rocker_center[0]-car_rocker_radius+car_rocker_offset_x
    ,car_rocker_center[1]-car_rocker_radius+CAR_CONTROL_SCREEN_Y+car_rocker_offset_y);
    break;
  
  case WM_TIMER:
    // 重新启动循环
    WM_RestartTimer(pMsg->Data.v, CAR_CONTROL_SCREEN_REFRESH_RATE);
    GUI_PID_GetState(&pState); 
  
    //用于刚进入页面后防止误触发
    if(pState.Pressed==0){   
      flag|= 0x2;          // 记忆没有发生触摸
    }else if(flag & 0x2){ // 表示松开后发生触摸
      flag|= 0x4;         // 有效触摸
    }
    if(pState.Pressed==1 && flag & 0x4){
      pState.y=pState.y-CAR_CONTROL_SCREEN_Y;  // 偏移到当前窗口
      if(dist(pState.x,pState.y,car_circular_center[0], car_circular_center[1])<car_rocker_offset_max)
      {
        // 认为触摸在圆内
        car_rocker_offset_x=pState.x-car_circular_center[0];
        car_rocker_offset_y=pState.y-car_circular_center[1];
      }else if(abs(pState.y) > car_circular_center[1]-car_circular_radius-30){
        // 认为触摸在圆外
        rad=radian(pState.x,pState.y,car_circular_center[0], car_circular_center[1]);
        car_rocker_offset_x=(unsigned int)car_rocker_offset_max*cos(rad);
        car_rocker_offset_y=(unsigned int)car_rocker_offset_max*sin(rad);
      }
//      xprintf("x:%d,y:%d,max:%d\r\n",car_rocker_offset_x,car_rocker_offset_y,car_rocker_offset_max);
      WM_InvalidateWindow(pMsg->hWin);
      flag |= 0x1;   
    }else{
      flag &= ~0x4;       // 清除有效触摸
      if(flag & 0x1){
        car_rocker_offset_x=0;
        car_rocker_offset_y=0;
        WM_InvalidateWindow(pMsg->hWin);
        flag &= ~0x1;  
      }
    }
    break;

   case WM_DELETE:
    GUI_MEMDEV_Delete(mem_handle);
    break;
    
  default:
    WM_DefaultProc(pMsg);
    break;
  }
}

/*********************************************************************
*
*       Public code
*
**********************************************************************
*/


WM_HWIN Createcar_control_win(void);
WM_HWIN Createcar_control_win(void) {
  WM_HWIN win[WIN_MAX_NUM]={0};
  // 从主页创建页面的必做1
  detete_last_win();                    //创建窗口前一定要删除之前的窗口
  init_page_parameter();
  
  win[0]=WM_CreateWindowAsChild(CAR_CONTROL_SCREEN_X, CAR_CONTROL_SCREEN_Y, CAR_CONTROL_SCREEN_XSIZE, CAR_CONTROL_SCREEN_YSIZE,
  WM_HBKWIN, WM_CF_SHOW, _cbDialog, 0);
  
  WM_CreateTimer(win[0], TIMER_0, CAR_CONTROL_SCREEN_REFRESH_RATE, 0);
  
  // 从主页创建页面的必做2
  switch_win(win,CONTROL_WIN_ID);
  return win[0];
}

// USER START (Optionally insert additional public code)
// USER END

/*************************** End of file ****************************/
