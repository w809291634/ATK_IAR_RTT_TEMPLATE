#include "ota.h"
#include "usart3.h"
#include "stdio.h"
#include "stdlib.h"
#include "string.h"
#include "sys.h"
#include "user_cmd.h"
#include "jsmn.h"
#include "flash.h"

/** 用户配置 **/
#define OTA_TASK1                  "OTA_check_version"
#define OTA_TASK2                  "OTA_download"
#define OTA_TASK3                  "OTA_download"
#define OTA_TASK4                  "OTA_download"
#define OTA_TASK5                  "OTA_download"

#define HTTP_DATA_BUF_SIZE          550
#define HTTP_HEADER_BUF_SIZE        50
#define MAX_ERROR_NUM               3  // 重试次数
#define MAX_TOKENS                  40
#define FRAGMENT_SIZE               512  // 数据包大小
#define HTTP_SEND                   "ONENET<--"
#define HTTP_RECV                   "ONENET-->"

static char http_flag;              // 标志位 
                                    // 位0 1：进行一次任务
                                    // 位1 备用
                                    // 位2 备用
                                    // 位3 0：当前有请求正在处理 1：处理结束  
                                    // 位4 1：开始接收正文 
                                    // 位5 1：正文接收完成 
#define REQUEST_OK                  {http_flag |= BIT_3;}
#define REQUEST_SENDED              {http_flag &= ~BIT_3;}
static char report_ver;           

/** 控制发送逻辑 **/
static char request_index;          // 请求的索引
static char current_request[30];
static char err_times;
static uint8_t* current_list;
static uint8_t post_version_list[]={5,0xff};          // 发送版本的请求列表
static uint8_t ota_update_list[]={1,2,3,4,5,0xff};    // OTA 升级的请求列表
/** 处理回复 **/
// 当前请求的数据缓存
static char http_buf[HTTP_DATA_BUF_SIZE]; // HTTP 协议的正文 和 接收处理buf
static uint16_t http_buf_len;
// 存储状态行信息
static uint16_t stats_code;               // 状态码
static uint8_t Content_Type;              // 正文类型  0：未知 1：json  2:octet-stream
static uint16_t Content_len;              // 正文长度
static char file_name[50];                // 正文长度
// 存储正文信息
static char res_msg[12];
static char target_version[24];
static uint32_t tid;
static uint32_t file_size;
// 下载分区信息
static uint32_t ota_partition_start;
static uint32_t ota_partition_size;
static uint16_t ota_fragment;
static uint16_t ota_total_fragment;
static uint32_t FlashDestination;

/** json数据处理 **/
jsmn_parser parser;
jsmntok_t tokens[MAX_TOKENS];

// esp32发送数据到服务器
static void esp32_send_IOT(const char * strbuf, unsigned short len)
{
  if(esp32_link){
    usart3_puts(strbuf,len);
    debug_ota(HTTP_SEND"%s\r\n",current_request);
  }
}

// 进行一次复位，可以再次发送请求
static void http_request_reset()
{
  // 缓存清理
  memset(http_buf,0,HTTP_DATA_BUF_SIZE);
  http_buf_len = 0;
  stats_code = 0;
  Content_Type =0;
  Content_len =0;
  
  // 清理必要的标志位
  http_flag &= ~BIT_4;
  http_flag &= ~BIT_5;
}

// 请求系统复位
static void http_system_reset()
{
  // 清除接收buf 和 数据
  http_request_reset();
  
  // 清理控制位
  http_flag=0;
  request_index =0;
  
  // flash 编程
  ota_fragment =0;
  FlashDestination =0;
  
  // 停止响应超时定时器
  softTimer_stop(HTTP_REQUEST_ID);
  
  // 清除错误次数
  err_times=0;
  
  // 标记更新结束
  updating=0;
  
  // 可以发送一次请求
  REQUEST_OK;
}

// http get 请求的基础函数
// url 地址
// Content_Type 正文类型
// range 范围
static void http_get_request(char *url,char* Content_Type,char* range)
{
  http_request_reset();
  if(esp32_link){
    char http_request[512]={0};
    char buf[256];
    // 请求行
    sprintf(buf,"GET %s HTTP/1.1\r\n",url);
    strcat(http_request,buf);
    // 协议头
    sprintf(buf,"Content-Type:%s\r\n",Content_Type);
    strcat(http_request,buf);
    sprintf(buf,"Authorization:%s\r\n",IOT_AUTHORIZATION);
    strcat(http_request,buf);
    sprintf(buf,"host:%s\r\n",IOT_HOST);
    strcat(http_request,buf);
    if(range!=NULL){
      sprintf(buf,"range:%s\r\n",range);
      strcat(http_request,buf);
    }
    // 空行
    strcat(http_request,"\r\n");
    
    // 向服务器发送请求
    esp32_send_IOT(http_request,strlen(http_request));
  }else{
    debug_info(INFO"Need to connect server");
  }
}

// http post 请求的基础函数
static void http_post_request(char *url)
{
  http_request_reset();
  if(esp32_link){
  
  }else{
    debug_info(INFO"Need to connect server");
  }
}

// 处理一条有效的回复
static void http_response_analysis(char *res)
{
  // 状态行
  if(strstr(res,"HTTP/1.1")){
    char *token = strtok(res, " ");
    unsigned char k = 0;
    while(token != NULL)
    {
      k++;
      switch(k)
      {
        case 1: break;    // 协议
        case 2: stats_code = atoi(token); break;
        case 3: break;
      }
      token = strtok(NULL, " ");
    }
  }
  // 正文类型
  else if(strstr(res,"Content-Type")){
    char* flag="Content-Type";
    char* info=strstr(res,flag)+strlen(flag)+1;
    // 获取内容
    if(strstr(info,"application/json"))Content_Type=1;
    else if(strstr(info,"application/octet-stream"))Content_Type=2;
    else Content_Type=0;
  }
  // 正文长度 Content-Length: 183
  else if(strstr(res,"Content-Length")){
    char* flag="Content-Length";
    char* info=strstr(res,flag)+strlen(flag)+1;
    // 获取内容
    Content_len = atoi(info);
  }
  // 正文描述，获取文件名
  else if(strstr(res,"Content-Disposition")){
    char* flag="filename=";
    char* info=strstr(res,flag)+strlen(flag);
    // 获取内容
    strcpy(file_name,info);
  }
  else{
    debug("res:%s not process\r\n",res);
  }
}

// http请求的数据结果
// 这里仅仅缓存 返回信息
// 在ESP32 的应用循环中回调
int http_data_handle(char *buf,uint16_t len)
{
  // 控制位 
  if(!(http_flag & BIT_0))return 0;
  
  /** 条件判断 **/
  // 当前 指令处理缓存 空间足够
  if(http_buf_len+len > HTTP_DATA_BUF_SIZE){
    debug_err(ERR"http_buf not enough space\r\n");
    http_system_reset();
    return -1;
  }
  memcpy(http_buf+http_buf_len,buf,len);
  http_buf_len=http_buf_len+len;
  
  // 产生一次 请求 接收完成 
  if(http_flag & BIT_4){
    if(http_buf_len == Content_len)
      http_flag |= BIT_5;
  }
  
  /** 接收正文 **/
  if(http_flag & BIT_4)return 0;
  
  /** 处理状态行和协议头 **/
  char cycle_counts=0;
  while(!(http_flag & BIT_4)){
    char* substring=strstr(http_buf,"\r\n");
    int vaild_len=strlen(http_buf);
    if(substring==NULL)break;

    /** 循环检测 **/
    cycle_counts++;
    if(cycle_counts > 6){
      debug_err(ERR"cycles exceeded,buf:%s,sub:%s\r\n",
                http_buf,substring);
      http_request_reset();
      return -1;
    }
    
    /** 去除多余字符 **/
    substring[0]=0;                       // 获取一个指令
    char *valid_reply=http_buf;           // 得到一条有效回复
    int offset=strlen(valid_reply)+2;      
    
    /** 处理状态行和协议头 **/
    if(strlen(valid_reply)>0)
      http_response_analysis(valid_reply);
    else  http_flag|=BIT_4;               // 开始接收正文


    /** 删除此条有效回复 **/
    leftShiftCharArray(http_buf,vaild_len,offset);
    http_buf_len = http_buf_len - offset;
  }
  return 0;
}

// 向服务器发送检查版本请求 任务1
static void OTA_check_version(void)
{
  if(sys_parameter.parameter_flag!=FLAG_OK){
    debug_err(ERR"sys_parameter error!\r\n");
    return;
  }
  
  char url[150];
  sprintf(url,"http://iot-api.heclouds.com/fuse-ota/%s/check?type=1&version=%s",
      IOT_PRO_ID_NAME,sys_parameter.app2_fw_version);
  http_get_request(url,"application/json",NULL);
}

// 向服务器上拉取镜像 任务2
static void OTA_download_package(char* range)
{
  char url[150];
  sprintf(url,"http://iot-api.heclouds.com/fuse-ota/%s/%d/download",
      IOT_PRO_ID_NAME,tid);
  http_get_request(url,"application/json",range);
}

// 向服务器发送当前版本
void OTA_POST_version(void)
{
//  if(sys_parameter.parameter_flag!=FLAG_OK){
//    debug_err(ERR"sys_parameter error!");
//    return;
//  }
//  char url[150];
//  sprintf(url,"http://iot-api.heclouds.com/fuse-ota/%s/check?type=1&version=%s",
//      IOT_PRO_ID_NAME,sys_parameter.app2_fw_version);
//  http_get_request(url,"application/json");
}

// 进行 http 请求的处理函数
// 包含进行 版本上传 和 OTA更新固件
static int http_request_handle(void)
{
  if(esp32_link!=1) return 0;
  
  // 控制位 
  if(!(http_flag & BIT_0))return 0;
  
  // 命令能够发送标志位
  if(!(http_flag & BIT_3))return 0;
  
  uint8_t cmd_id = current_list[request_index];
  char temp[50];
  // 开始发送命令
  switch(cmd_id){
    case 1:{
      /* OTA_check_version */
      // 标记分区状态
      if(download_part==1) sys_parameter.app1_flag=APP_ERR;
      else if(download_part==2) sys_parameter.app2_flag=APP_ERR;
      write_sys_parameter();
      
      strcpy(current_request,OTA_TASK1);
      OTA_check_version();
      softTimer_start(HTTP_REQUEST_ID,5000);
    }break;
    case 2:{
      /* 进行分区下载 */
      sprintf(temp,"%d-%d",0+512*ota_fragment,511+512*ota_fragment);
      sprintf(current_request,"%s range:%s",OTA_TASK2,temp);
      OTA_download_package(temp);
      softTimer_start(HTTP_REQUEST_ID,5000);
    }break;
    case 3:{
      /*  */
      
      softTimer_start(HTTP_REQUEST_ID,5000);
    }break;  
    case 4:{
      /*  */

      softTimer_start(HTTP_REQUEST_ID,5000);
    }break;
    case 5:{

      softTimer_start(HTTP_REQUEST_ID,5000);
    }break;
    case 0xff:{
      /* 列表请求完成 */

      debug_info(INFO"CONNECT SUCCESS!\r\n");
    }return 1;
    
    default:{
      http_system_reset();
      debug_err(ERR"instruction exceeeded!\r\n");
    }break;
  }
  REQUEST_SENDED;
  return 0;
}

// 进行重试
static void http_request_retry(void)
{
  // 控制位 
  if(!(http_flag & BIT_0))return;
  
  err_times++; 
  if(err_times>=MAX_ERROR_NUM){ 
    debug_err(ERR"Attempts Exceeded\r\n"); 
    http_system_reset(); 
  } 
  else REQUEST_OK;
}

// 编写在原始json数据中的字符串比较函数
static int jsoneq(const char *json, jsmntok_t *tok, const char *s) 
{
  if(tok->type == JSMN_STRING && (int)strlen(s) == tok->end - tok->start &&
    strncmp(json + tok->start, s, tok->end - tok->start) == 0) return 0;
  return -1;
}

// 处理 http 的响应
// http 请求的情况1
static void http_respond_handle(void)
{
  // 控制位 
  if(!(http_flag & BIT_0)) return;
  
  if(!(http_flag & BIT_5)) return;
  
  char temp[50]={0};
  /* 开始进行响应数据处理 */
  // 处理 检查升级任务
  if(strstr(current_request,OTA_TASK1)){
    // 检查状态行
    if(stats_code!=200 || Content_Type!=1){
      http_request_retry(); 
      debug_err(ERR"status error\r\n");
    }
    
    // 获取JSON中的对象数据
    int r = jsmn_parse(&parser, http_buf, strlen(http_buf), tokens, MAX_TOKENS);
    if(r>0){
      for (int i = 1; i < r; i++) {
        // 获取 JSON 对象位置信息
        char *p =http_buf + tokens[i + 1].start;
        int len = tokens[i + 1].end - tokens[i + 1].start;
        if (jsoneq(http_buf, &tokens[i], "msg") == 0) {
          if(len < sizeof(res_msg)){
            memcpy(res_msg, p, len);res_msg[len]='\0';
          }
          else debug_err(ERR"buf not space\r\n");
          i++;
        } 
        else if (jsoneq(http_buf, &tokens[i], "target") == 0) {
          if(len < sizeof(target_version)){
            memcpy(target_version, p, len);target_version[len]='\0';
          }
          else debug_err(ERR"buf not space\r\n");
          i++;
        } 
        else if (jsoneq(http_buf, &tokens[i], "tid") == 0) {
          memcpy(temp, p, len);temp[len]='\0';
          tid = atoi(temp);
          i++;
        } 
        else if (jsoneq(http_buf, &tokens[i], "size") == 0) {
          memcpy(temp, p, len);temp[len]='\0';
          file_size = atoi(temp);
          i++;
        } 
      }
      // 显示接收信息
      debug_ota(HTTP_RECV"msg:%s\r\n",res_msg);
      
      // 根据信息处理下一步
      if(strstr(res_msg,"succ")) {
        /* 获取信息 */
        FlashDestination = ota_partition_start;
        ota_total_fragment = file_size/FRAGMENT_SIZE + ((file_size%FRAGMENT_SIZE)?1:0);
        
        /* 检查地址 */
        u32 addrx=ota_partition_start;           // 写入起始地址
        u32 end_addr=ota_partition_start+file_size;   // 接收文件的写入终止地址，加1
        
        if (file_size > ota_partition_size  || 
            addrx < STM32_FLASH_BASE ||       // 起始地址检查
            addrx % 4 )
        {
          debug_err(ERR"Programming address error\r\n");
          http_system_reset();
        }

        /* 擦除需要的flash部分 */
        FLASH_Unlock();
        FLASH_DataCacheCmd(DISABLE);
        
        while(addrx < end_addr)	
        {
          if(*(vu32*)addrx!=0XFFFFFFFF)           // 有非0XFFFFFFFF的地方,要擦除这个扇区,同时进行校验
          {   
            uint16_t Sector_num = STMFLASH_GetFlashSector(addrx);
            if(FLASH_EraseSector(Sector_num,VoltageRange_3)!=FLASH_COMPLETE){   //VCC=2.7~3.6V之间!!
              FLASH_DataCacheCmd(ENABLE);	
              FLASH_Lock();
              
              debug_err(ERR"Erase flash error!\r\n");
              http_system_reset();
            }
          }else addrx+=4;
        } 
        FLASH_DataCacheCmd(ENABLE);	              // FLASH擦除结束,开启数据缓存
        FLASH_Lock();                             // 上锁
        
        // 可以发送下一次请求
        err_times=0;
        REQUEST_OK;
        request_index++; 
      }else http_request_retry();    
    }else http_request_retry();
  }
  // 处理下载任务
  else if(strstr(current_request,OTA_TASK2)){
    if(stats_code!=206 || Content_Type!=2 || FlashDestination==0){
      http_request_retry(); 
      debug_err(ERR"status error\r\n");
    }

    uint32_t RamSource = (uint32_t)http_buf;
    /* 数据编程 */
    FLASH_Unlock();	
    FLASH_DataCacheCmd(DISABLE); 
    for (int j = 0;(j < Content_len) && (FlashDestination <  ota_partition_start + file_size);j += 4)
    {
      FLASH_ProgramWord(FlashDestination, *(uint32_t*)RamSource);

      if (*(uint32_t*)FlashDestination != *(uint32_t*)RamSource)
      {
        FLASH_DataCacheCmd(ENABLE);	
        FLASH_Lock();
        // 编程错误，重新开始
        http_system_reset();
      }
      FlashDestination += 4;
      RamSource += 4;
    }
    FLASH_DataCacheCmd(ENABLE);	
    FLASH_Lock();
    
    // 处理结果
    if(FlashDestination >= ota_partition_start + file_size){
      debug_ota(HTTP_RECV"Progress 100%%\r\n");
      debug_ota("OTA update Successfully!FW version:%s\r\n",target_version);
      debug("Name: %s \r\n",(char*)file_name);
      debug("Size: %d Bytes\r\n",file_size);
      // 写标志
      if(download_part==1) {
        strcpy(sys_parameter.app1_fw_version,target_version);
        sys_parameter.app1_flag=APP_OK;
      }
      else if(download_part==2) {
        sys_parameter.app2_flag=APP_OK;
      }
      write_sys_parameter();
      
      // 更新完成
      REQUEST_OK;
      request_index++; 
      http_system_reset();
    }else{
      // 继续下载
      ota_fragment++;
      debug_ota(HTTP_RECV"Progress %.2f%%\r\n",(double)ota_fragment / (double)ota_total_fragment * 100);
      REQUEST_OK;
      err_times=0;
    }
  }

  // 一个请求处理结束
  http_request_reset();
}

// http 请求超时
// 通常一个请求响应会比较快，超时则进行重试
// http 请求的情况2
static void http_request_timeout()
{
  debug_war(WARNING"<%s> request timeout:\r\n",current_request);
  http_request_retry();
}

// 进行 ota 升级系统的初始化
void OTA_system_init(void)
{
  jsmn_init(&parser);
  softTimer_create(HTTP_REQUEST_ID,MODE_ONE_SHOT,http_request_timeout);
  http_system_reset();     // 首次复位
}

// 应用处理循环
void OTA_system_loop(void)
{
  http_request_handle();
  http_respond_handle();
}

// 主动上报一次版本
void OTA_report_hw_version(void)
{
  if(!report_ver){
    http_system_reset();     // 首次复位
    current_list=post_version_list;
    http_flag |= BIT_0;
  }
}

// 进行一次 OTA 更新
void OTA_update_start(void)
{
  if(esp32_link!=1)return ;
    
  // 判断是否正在进行更新
  if(updating==1){
    debug_war(WARNING"updating in progress!\r\n");
    return ;
  }
  
  if(!(http_flag & BIT_0)){
    http_system_reset();     // 首次复位
    current_list=ota_update_list;
    
    // 进行分区判断
    if(download_part==1){
      /* 分区1 */
      FlashDestination = APP1_START_ADDR;
      ota_partition_start=APP1_START_ADDR;
      ota_partition_size=APP1_SIZE;
    }
    else if(download_part==2){
      /* 分区2 */
      FlashDestination = APP2_START_ADDR;
      ota_partition_start=APP2_START_ADDR;
      ota_partition_size=APP2_SIZE;
    }else {
      debug_err(ERR"Please set partition to 1 or 2!\r\n");
      return ;
    }
    
    // 启动更新
    printf("download partition is app%d,start:0x%08x,size:%d Bytes\r\n",
    download_part,ota_partition_start,ota_partition_size);
    updating =1;
    http_flag |= BIT_0;
  }else{
    debug_info(INFO"HTTP requesting\r\n");
  }
}
