/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.32                          *
*        Compiled Oct  8 2015, 11:59:02                              *
*        (c) 2015 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/

// USER START (Optionally insert additional includes)
// USER END

#include "DIALOG.h"
#include "GUI_app/gui_thread.h"
#include "GUI.h"
#include "LCD/lcd.h"
#include "config.h"

/*********************************************************************
*
*       注意
*  1、所有图标必须是正方形
*
**********************************************************************
*/

/*********************************************************************
*
*       user config
*
**********************************************************************
*/

#define MAIN_PAGE_SMILE_ICON_Y0   (LCD_ysize/2-STATUS_BAR_HEIGHT)   //笑脸图标的中心点Y方向
#define VIEW_ICON_BK_COLOR        0x00FFC880
#define ICON_BAR_BK_COLOR         0x00F0e6c8
#define ICON_SELECTED_COLOR       (0x22uL<<24)|GUI_LIGHTBLUE
/********VIEW_ICON********/
//锁定画面尺寸定义
#define VIEW_ICON_RATE      0.72f                            //解锁条在界面的比例位置
#define VIEW_ICON_X         0
#define VIEW_ICON_Y         STATUS_BAR_HEIGHT               //滑动图标区的Y起点
#define VIEW_ICON_XSIZE     (LCD_xsize-VIEW_ICON_X)
#define VIEW_ICON_YSIZE     (int)((LCD_ysize-VIEW_ICON_Y)*VIEW_ICON_RATE)
#define VIEW_SCREEN_YSIZE   (LCD_ysize-VIEW_ICON_Y)         //主页的Y尺寸

//显示控制参数
#define VIEW_ICON_POSITIONING_VALUE  6       //复位定位值
#define VIEW_ICON_REFRESH_RATE 5  //主页VIEW_ICON更新率
//图标和主页数量
#define MAIN_PAGE_NUM     2       //主页的数量
#define ICON_NUM_X        3       //每行图标个数
#define ICON_NUM_Y        3       //每列图标个数
#define ICON_X_INTERVAL   10      //每行图标间隔
#define ICON_Y_INTERVAL   10      //每列图标间隔

#define ICON_NUM          (ICON_NUM_X*ICON_NUM_y)   //单页支持的最大图标数量
#define VIEW_ICON_EDGE_XSIZE    0       //图标被选中后的边框距离，单位像素
#define VIEW_ICON_EDGE_YSIZE    4       //图标被选中后的边框距离，单位像素
#define TEXT_EDGE_SIZE    2       //文本和位图间距，单位像素
#define VIEW_ICON_TEXT_OFFSET    2       //文本偏移
#define TEXT_FONT         GUI_FONT_6X8_ASCII  //使用字体
  
//调试
#define VIEW_DEBUG        0

/********ICON_BAR********/
#define ICON_BAR_X         0
#define ICON_BAR_Y         (VIEW_ICON_Y+VIEW_ICON_YSIZE)    //图标条的Y起点,相对于LCD
#define ICON_BAR_XSIZE     (LCD_xsize-ICON_BAR_X)
#define ICON_BAR_YSIZE     (LCD_ysize-ICON_BAR_Y)

#define ICON_BAR_OUTSIDE_INTERVAL      30     	//图标区域X间距
#define ICON_BAR_MIDDLE_INTERVAL      10     	//图标区域X间距
#define ICON_BAR_Y_INTERVAL      10    	//图标区域y间距

#define ICON_BAR_REFRESH_RATE 1000  	//主页 ICON_BAR 更新率
#define ICON_BAR_ICON_NUM_X    	3		//行个数
#define ICON_BAR_ICON_NUM_Y     1		//列个数
#define ICON_BAR_TEXT_EDGE_SIZE    2       //文本和位图间距，单位像素
#define ICON_BAR_TEXT_OFFSET    -1       //文本偏移

#define ICON_BAR_EDGE_SIZE    2       //图标被选中后的边框距离，单位像素
//行为相关
#define MOVE_TRIGGER_DISTANCE   10   //判定为触摸移动的距离，单位像素
/*********************************************************************
*
*       variables
*
**********************************************************************
*/
//函数声明
static void clean_icon_view(void);
static void clean_icon_bar(void);
static void clean_all_icon_flag(void);
static void init_all_mainpage(void);
static void init_mainpage(void);
WM_HWIN CreateTips(void);

//图标位图
extern GUI_CONST_STORAGE GUI_BITMAP bmiconview_appstore;
extern GUI_CONST_STORAGE GUI_BITMAP bmiconview_calculator;
extern GUI_CONST_STORAGE GUI_BITMAP bmiconview_calendar;
extern GUI_CONST_STORAGE GUI_BITMAP bmiconview_camera;
extern GUI_CONST_STORAGE GUI_BITMAP bmiconview_clock;
extern GUI_CONST_STORAGE GUI_BITMAP bmiconview_compass;
extern GUI_CONST_STORAGE GUI_BITMAP bmiconview_menssages;
extern GUI_CONST_STORAGE GUI_BITMAP bmiconview_music;
extern GUI_CONST_STORAGE GUI_BITMAP bmiconview_phone;
extern GUI_CONST_STORAGE GUI_BITMAP bmiconview_photos;
extern GUI_CONST_STORAGE GUI_BITMAP bmiconview_weather;


//背景位图
extern GUI_CONST_STORAGE GUI_BITMAP bmicon_smile;

// 图标回调函数
extern WM_HWIN Createcar_control_win(void);

//_icon图标对象表示的是包含位图和文本的所有区域
//由于都是使用GUI等接口进行绘制图形，如果使用窗口管理器，在哪个窗口绘制就是坐标系就是这个窗口原点。
struct _icon {
  //变量
  unsigned char flag;             //图标状态，1：被选择 2：被双击
  signed short icon_x;            //图标左上角点x坐标,
  signed short icon_y;            //图标左上角点y坐标
  unsigned short icon_xsize;        //图标x尺寸
  unsigned short icon_ysize;        //图标y尺寸
  
  signed short text_y;            //文本区域左上角点y坐标,包含位图和文本间距
  signed short text_c_x;          //文本区域中心点x坐标
  signed short text_h_y;          //文本区域顶点Y坐标
  
  signed short bitmap_x;          //位图区域左上角点x坐标
  signed short bitmap_y;          //位图区域左上角点y坐标
  unsigned short bitmap_xsize;      //位图区域x尺寸，起点和图标一致
  unsigned short bitmap_ysize;      //位图区域y尺寸
  unsigned short bitmap_size;       //位图尺寸,图标区域，始终正方形
  
  float bitmap_rate;                //位图缩放比例
  WM_HWIN (*fun)(void);                // 双击后的回调函数
  GUI_MEMDEV_Handle men_handle;
  //赋初值
  const char       * pText;         //图标名称
  const GUI_BITMAP * pBitmap;       //图标位图
};
typedef struct _icon _ICON;
typedef struct _icon* _ICON_T;

struct _page {
  unsigned char init;               //初始化状态
  unsigned char icon_num;           //图标数量
  _ICON_T icon_list;                //图标集
  const GUI_FONT * pFont;
};
typedef struct _page _PAGE;
typedef struct _page* _PAGE_T;

//主页1图标列表
static _ICON icon_list1[]={
  {.pText="control",.pBitmap=&bmiconview_appstore,.fun=Createcar_control_win},
  {.pText="calendar",.pBitmap=&bmiconview_calendar,.fun=CreateTips},
  {.pText="camera",.pBitmap=&bmiconview_camera,.fun=CreateTips},
};
//主页2图标列表
static _ICON icon_list2[]={
  {.pText="menssages",.pBitmap=&bmiconview_menssages,.fun=CreateTips},
  {.pText="weather",.pBitmap=&bmiconview_weather,.fun=CreateTips},
};

//icon_bar 图标列表
static _ICON icon_bar_list[]={
  {.pText="phone",.pBitmap=&bmiconview_phone,.fun=CreateTips},
  {.pText="app",.pBitmap=&bmiconview_appstore,.fun=CreateTips},
  {.pText="photo",.pBitmap=&bmiconview_photos,.fun=CreateTips},
};

static _PAGE _main_page[MAIN_PAGE_NUM]={
{.icon_num=GUI_COUNTOF(icon_list1),.icon_list=icon_list1,.pFont=TEXT_FONT},
{.icon_num=GUI_COUNTOF(icon_list2),.icon_list=icon_list2,.pFont=TEXT_FONT},
};

//变量
static signed short scr_offset_c=0;         //屏幕偏移的当前值
static signed short scr_offset_o=0;         //屏幕偏移的目标值
static unsigned char c_page=0;              // 0表示第一页  1表示第二页
static signed char icon_view_bp_offset=0;         //位图偏移到中心点的偏移量 ,注意位图始终为同比例边长   
static signed char icon_bar_bp_offset=0;         //位图偏移到中心点的偏移量 ,注意位图始终为同比例边长   

//移动行为
static signed short move_touch_sxf;             //移动触发时的X起点（加上偏移）
static signed short move_touch_sx;              //移动触发时的X起点
static signed short move_touch_x;               //点击时的x值
static signed short move_touch_c;               //此处触发的移动值
static unsigned char move_touch_f;              //移动触发开始标志位, 1：表示没有触发  2：触摸  3：触摸并滑动

//触摸单击行为
static signed short touch_click_x;               //点击时的x值
static signed short touch_click_y;               //点击时的y值
static unsigned char touch_click_f;              //点击标志,1：触摸单击触发  2：触摸单击已经绘制

//触摸双击行为
static unsigned char double_click;               //双击触发

//页面稳定
static unsigned char page_stability_f=1;    //自动返回触发开始标志位
static unsigned short icon_bar_y=0;      //预计算出icon_bar_y的起点

//窗口刷新标志位
static unsigned char win_refresh;       //标志位 第一位 icon_view 第二位 icon_bar
//窗口句柄
static WM_HWIN icon_view;
static WM_HWIN icon_bar;
static WM_HWIN icon_tips;

/*********************************************************************
*
*       Defines
*
**********************************************************************
*/
#define ID_WINDOW_0         (GUI_ID_USER + 0x00)
#define ID_ICONVIEW_0       (GUI_ID_USER + 0x01)
#define ID_TEXT_0           (GUI_ID_USER + 0x02)
#define ID_BUTTON_0         (GUI_ID_USER + 0x03)
#define ID_FRAMEWIN_0       (GUI_ID_USER + 0x04)
#define TIMER_0           0
#define TIMER_1           1

static void init_all_mainpage(void)
{
  double_click=0;
  scr_offset_c=0;
  scr_offset_o=0;
  move_touch_f=0;
  c_page=0;
  clean_all_icon_flag();
}

static void init_mainpage(void)
{
  double_click=0;
  move_touch_f=0;
  clean_all_icon_flag();
}

#if(VIEW_DEBUG==1)
static void debug_view_icon()
{
  unsigned char i;
  unsigned char t;
  for(i=0;i<MAIN_PAGE_NUM;i++){                   //页号
    for(t=0;t<_main_page[i].icon_num;t++) {       //图标号
      //绘制图标区域   
      GUI_SetColor(GUI_WHITE);        
      GUI_DrawRect(_main_page[i].icon_list[t].icon_x, _main_page[i].icon_list[t].icon_y, 
        _main_page[i].icon_list[t].icon_x+_main_page[i].icon_list[t].icon_xsize, 
        _main_page[i].icon_list[t].icon_y+_main_page[i].icon_list[t].icon_ysize);
      
      //绘制位图区域  
      GUI_SetColor(GUI_BLACK);       
      GUI_DrawRect(_main_page[i].icon_list[t].bitmap_x, _main_page[i].icon_list[t].bitmap_y, 
        _main_page[i].icon_list[t].bitmap_x+_main_page[i].icon_list[t].bitmap_size, 
        _main_page[i].icon_list[t].bitmap_y+_main_page[i].icon_list[t].bitmap_size); 
      
      //绘制文本区域
      GUI_SetColor(GUI_ORANGE);
      GUI_DrawRect(_main_page[i].icon_list[t].icon_x, _main_page[i].icon_list[t].text_y, 
        _main_page[i].icon_list[t].icon_x+_main_page[i].icon_list[t].icon_xsize, 
        _main_page[i].icon_list[t].text_y+_main_page[i].pFont->YSize+TEXT_EDGE_SIZE);
      
      //绘制文本中心
      GUI_SetColor(GUI_RED);
      GUI_FillCircle(_main_page[i].icon_list[t].text_c_x, _main_page[i].icon_list[t].text_h_y, 2);
    }
  }
}

static void debug_icon_bar()
{
  unsigned char t;               
  for(t=0;t<GUI_COUNTOF(icon_bar_list);t++) {       //图标号
    //绘制图标区域   
    GUI_SetColor(GUI_WHITE);        
    GUI_DrawRect(icon_bar_list[t].icon_x, icon_bar_list[t].icon_y, 
      icon_bar_list[t].icon_x+icon_bar_list[t].icon_xsize, 
      icon_bar_list[t].icon_y+icon_bar_list[t].icon_ysize);
    
    //绘制位图区域  
    GUI_SetColor(GUI_BLACK);       
    GUI_DrawRect(icon_bar_list[t].bitmap_x, icon_bar_list[t].bitmap_y, 
      icon_bar_list[t].bitmap_x+icon_bar_list[t].bitmap_size, 
      icon_bar_list[t].bitmap_y+icon_bar_list[t].bitmap_size); 
    
    //绘制文本区域
    GUI_SetColor(GUI_ORANGE);
    GUI_DrawRect(icon_bar_list[t].icon_x, icon_bar_list[t].text_y, 
      icon_bar_list[t].icon_x+icon_bar_list[t].icon_xsize, 
      icon_bar_list[t].text_y+_main_page[0].pFont->YSize+ICON_BAR_TEXT_EDGE_SIZE);
    
    //绘制文本中心
    GUI_SetColor(GUI_RED);
    GUI_FillCircle(icon_bar_list[t].text_c_x, icon_bar_list[t].text_h_y, 2);
  }
}
#endif



/*********************************************************************
*
*       viewicon_cbDialog
*/
static void clean_icon_view(void)
{
  unsigned char i;
  unsigned char t;
  //清除VIEW_ICON
  for(i=0;i<MAIN_PAGE_NUM;i++){                   //页号
    for(t=0;t<_main_page[i].icon_num;t++) {       //图标号
      _main_page[i].icon_list[t].flag=0;
    }
  }
}

static void clean_icon_bar(void)
{
  unsigned char t;
  //清除ICON_BAR
  for(t=0;t<ICON_BAR_ICON_NUM_X;t++) {            //图标号
      icon_bar_list[t].flag=0;
  }
}
    
static void clean_all_icon_flag(void)
{
  clean_icon_view();
  clean_icon_bar(); 
}
  
static void viewicon_cbDialog(WM_MESSAGE * pMsg) 
{
//  WM_HWIN hItem;
  unsigned char i;
  unsigned char t;
  unsigned short temp;
  unsigned short temp1;
  GUI_PID_STATE  pState;
  
//  long ram;

  switch (pMsg->MsgId) {
  case WM_CREATE: 
    //初始化页参数
  
    // 优化：后期可以分段创建子窗口
    for(i=0;i<MAIN_PAGE_NUM;i++){                   //页号
      for(t=0;t<_main_page[i].icon_num;t++) {       //图标号
        /*图标区域定位*/
        _main_page[i].icon_list[t].icon_xsize=(VIEW_ICON_XSIZE-(ICON_NUM_X+1)*ICON_X_INTERVAL)/ICON_NUM_X;
        _main_page[i].icon_list[t].icon_ysize=(VIEW_ICON_YSIZE-(ICON_NUM_Y+1)*ICON_Y_INTERVAL)/ICON_NUM_Y;
        temp=t%ICON_NUM_X;                  //所在行
        //图标区域的左上角起点X坐标
        _main_page[i].icon_list[t].icon_x=(temp+1)*ICON_X_INTERVAL+temp*_main_page[i].icon_list[t].icon_xsize+VIEW_ICON_XSIZE*i;
        temp=t/ICON_NUM_X;                //所在列
        _main_page[i].icon_list[t].icon_y=(temp+1)*ICON_Y_INTERVAL+temp*_main_page[i].icon_list[t].icon_ysize;
        //计算尺寸
        _main_page[i].icon_list[t].text_y=_main_page[i].icon_list[t].icon_y+
            _main_page[i].icon_list[t].icon_ysize-
            _main_page[i].pFont->YSize-TEXT_EDGE_SIZE;
        
        _main_page[i].icon_list[t].bitmap_xsize=_main_page[i].icon_list[t].icon_xsize;
        _main_page[i].icon_list[t].bitmap_ysize=_main_page[i].icon_list[t].text_y-_main_page[i].icon_list[t].icon_y;
        
        //文本区域的中心点起点X坐标,由icon_x计算
        _main_page[i].icon_list[t].text_c_x=(_main_page[i].icon_list[t].icon_x+_main_page[i].icon_list[t].bitmap_xsize/2);
        _main_page[i].icon_list[t].text_h_y=_main_page[i].icon_list[t].text_y+TEXT_EDGE_SIZE+VIEW_ICON_TEXT_OFFSET;
        
        //绘制位图比例和选边
        if(_main_page[i].icon_list[t].bitmap_xsize>_main_page[i].icon_list[t].bitmap_ysize){
          //以Y尺寸绘图,y为短边
          temp=(_main_page[i].icon_list[t].bitmap_xsize - _main_page[i].icon_list[t].bitmap_ysize)/2;       //X方向多余部分，绘制正方形图标
          //位图区域的左上角起点X坐标,由icon_x计算
          _main_page[i].icon_list[t].bitmap_x=_main_page[i].icon_list[t].icon_x+temp;
          _main_page[i].icon_list[t].bitmap_y=_main_page[i].icon_list[t].icon_y;
          _main_page[i].icon_list[t].bitmap_rate=
            (float)_main_page[i].icon_list[t].bitmap_ysize/_main_page[i].icon_list[t].pBitmap->XSize;   //缩放图标比例
          _main_page[i].icon_list[t].bitmap_size=_main_page[i].icon_list[t].bitmap_ysize;
        }else{
          //以x尺寸绘图,x为短边
          temp=(_main_page[i].icon_list[t].bitmap_ysize - _main_page[i].icon_list[t].bitmap_xsize)/2;  
          //位图区域的左上角起点X坐标,由icon_x计算
          _main_page[i].icon_list[t].bitmap_x=_main_page[i].icon_list[t].icon_x;
          _main_page[i].icon_list[t].bitmap_y=_main_page[i].icon_list[t].icon_y+temp;
          _main_page[i].icon_list[t].bitmap_rate=
            (float)_main_page[i].icon_list[t].bitmap_xsize/_main_page[i].icon_list[t].pBitmap->XSize;   //缩放图标比例 
          _main_page[i].icon_list[t].bitmap_size=_main_page[i].icon_list[t].bitmap_xsize;
        }  
        
        /*创建内存设备*/    
        //内存设备区域的左上角起点X坐标  ,由icon_x计算        
         _main_page[i].icon_list[t].men_handle=GUI_MEMDEV_CreateFixed(_main_page[i].icon_list[t].bitmap_x, _main_page[i].icon_list[t].bitmap_y,
        _main_page[i].icon_list[t].pBitmap->XSize, _main_page[i].icon_list[t].pBitmap->YSize,
        GUI_MEMDEV_HASTRANS, GUI_MEMDEV_APILIST_16, GUICC_M565);
        //绘制位图
        GUI_MEMDEV_Select(_main_page[i].icon_list[t].men_handle);
        GUI_DrawBitmap(_main_page[i].icon_list[t].pBitmap, 
        _main_page[i].icon_list[t].bitmap_x,
        _main_page[i].icon_list[t].bitmap_y);     
      }
    }
    //提示此时生成位图的正方形边长
    i=0; t=0;
    //对齐到位图区域中心
    icon_view_bp_offset=-(_main_page[i].icon_list[t].pBitmap->XSize-_main_page[i].icon_list[t].bitmap_size)/2;

    xprintf("icon_view bitmap_size:%d\r\n",_main_page[i].icon_list[t].bitmap_size);
//    ram=GUI_ALLOC_GetNumFreeBytes();      //获取GUI剩余内存空间
//    xprintf("icon_view GUI_Free_ram is %d\r\n",ram);
      
    //重新指定LCD输出
    GUI_MEMDEV_Select(0);
    icon_bar_y=VIEW_ICON_Y+VIEW_ICON_YSIZE;
    break;
  
  case WM_PAINT:
    //重绘背景
//    temp=xtime();
    GUI_SetBkColor(VIEW_ICON_BK_COLOR);         //自定义调色
    GUI_Clear();
//    GUI_DrawBitmapEx(&bmicon_smile, VIEW_ICON_XSIZE/2, //耗费CPU资源
//    MAIN_PAGE_SMILE_ICON_Y0,bmicon_smile.XSize/2,bmicon_smile.YSize/2,1000,1000);  
#if(VIEW_DEBUG==1)
    debug_view_icon();
#endif

    //绘制滑动图标区域
    for(i=0;i<MAIN_PAGE_NUM;i++){                   //页号
      for(t=0;t<_main_page[i].icon_num;t++) {       //图标号
        //绘制被选择背景
        if(c_page==i && _main_page[i].icon_list[t].flag==1 ){
          GUI_SetColor(ICON_SELECTED_COLOR);
          GUI_FillRect(_main_page[i].icon_list[t].icon_x-c_page*VIEW_ICON_XSIZE - VIEW_ICON_EDGE_XSIZE,
          _main_page[i].icon_list[t].icon_y - VIEW_ICON_EDGE_YSIZE,
          _main_page[i].icon_list[t].icon_x+_main_page[i].icon_list[t].icon_xsize-c_page*VIEW_ICON_XSIZE + VIEW_ICON_EDGE_XSIZE ,
          _main_page[i].icon_list[t].icon_y+_main_page[i].icon_list[t].icon_ysize + VIEW_ICON_EDGE_YSIZE  );
        }

//        //绘制图标区域      
        GUI_MEMDEV_WriteAt(_main_page[i].icon_list[t].men_handle,
        _main_page[i].icon_list[t].bitmap_x+icon_view_bp_offset+scr_offset_c
        ,_main_page[i].icon_list[t].bitmap_y+icon_view_bp_offset+VIEW_ICON_Y);
        
//      GUI_MEMDEV_WriteExAt();消耗大
        
        //绘制文本区域
        GUI_SetColor(GUI_BLACK);
        GUI_SetTextMode(GUI_TM_TRANS);          //透明背景
        GUI_DispStringHCenterAt(_main_page[i].icon_list[t].pText, _main_page[i].icon_list[t].text_c_x+scr_offset_c, 
        _main_page[i].icon_list[t].text_h_y);
      }
    }
//    temp1=xtime();
//    xprintf("time:%d\r\n",temp1-temp);
  break;

  case WM_TIMER:
//    temp=xtime();
    if(double_click==1){
      WM_DeleteTimer(pMsg->Data.v);       //双击行为后 main_page 不在更新
      break;
    }
    else{
      WM_RestartTimer(pMsg->Data.v, VIEW_ICON_REFRESH_RATE);
    }
    GUI_PID_GetState(&pState); 
    
    // 移动行为 页面没有达到 单击行为 
    if(move_touch_f==3 || scr_offset_o!=scr_offset_c){
      WM_InvalidateWindow(pMsg->hWin);
    }
    
    // 点击行为刷新
    if( touch_click_f==1 || touch_click_f==2)            //VIEW_ICON 中的图标触发选中
    {
      WM_InvalidateWindow(pMsg->hWin);
      WM_SendMessageNoPara(icon_bar, MSG_WIN_INVAILD);   //发送到 icon_bar ，刷新页面
    }
    /***********行为***********/

    /*行为：点击 和 滑动 */
    if(pState.Pressed==1 && move_touch_f==1 ){
      move_touch_sxf=pState.x-scr_offset_c;      // 添加初始偏移值
      move_touch_sx=pState.x;
      move_touch_f=2;                           // 记忆发生触摸
    }
    if(pState.Pressed==1 && move_touch_f>1){
      move_touch_x=pState.x;
      move_touch_c=move_touch_x-move_touch_sx;      //当前触摸滑动的移动值
      
      //确认是否为 滑动 行为
      if(abs(move_touch_c)>MOVE_TRIGGER_DISTANCE){
        /*行为：滑动 */
        if(pState.y>VIEW_ICON_Y && pState.y<icon_bar_y)     //需要在指定区域滑动
        {  
          // 确认为滑动，清除掉对应的标志位
          if(win_refresh&0x1){
            clean_icon_view();
            WM_InvalidateWindow(pMsg->hWin);
            win_refresh&=0x2;         
          }
          if(win_refresh&0x2){
            clean_icon_bar(); 
            WM_SendMessageNoPara(icon_bar, MSG_WIN_INVAILD);  
            win_refresh&=0x1;                           //清除这个刷新标记
          }

          move_touch_f=3;                               //触发触摸移动标志
          scr_offset_c=move_touch_x-move_touch_sxf;     //在初始偏移值基础上进行增减
          
          //滑动页面两侧极限位置限制
          if(scr_offset_c < (-(MAIN_PAGE_NUM-1)*VIEW_ICON_XSIZE)){
            scr_offset_c = -(MAIN_PAGE_NUM-1)*VIEW_ICON_XSIZE;
            move_touch_c=0;
          }
          if(scr_offset_c > 0){
            scr_offset_c = 0;
            move_touch_c=0;
          } 
        }
        else{       //超出滑动区域
          move_touch_c=0;
        }          
      }
      else
      {
        /*行为：点击图标*/
        //touch_click_f 
        // 0: 一次单击检测开始
        // 1: VIEW_ICON 选中
        // 2: ICON_BAR 选中
        // 3: 都没 选中
        if(move_touch_f==2 && page_stability_f==1 && touch_click_f==0 && double_click==0){          //触发点击行为,没有触发翻页
          touch_click_x =  pState.x;
          touch_click_y =  pState.y;
          
          // 确定 VIEW_ICON 哪个图标被选中
          for(i=0;i<MAIN_PAGE_NUM;i++){                   //页号
            for(t=0;t<_main_page[i].icon_num;t++) {       //图标号
              temp = _main_page[i].icon_list[t].icon_x + VIEW_ICON_X - c_page*VIEW_ICON_XSIZE;   //当前页的图标X起点
              temp1 = _main_page[i].icon_list[t].icon_y + VIEW_ICON_Y;                //当前页的图标Y起点
              if( i==c_page  
              && touch_click_f == 0
              && touch_click_x - temp < _main_page[i].icon_list[t].icon_xsize 
              && touch_click_x > temp 
              && touch_click_y- temp1 < _main_page[i].icon_list[t].icon_ysize 
              && touch_click_y > temp1  )
              {
                /*行为：双击 图标*/
                if(_main_page[i].icon_list[t].flag==1){        
                  double_click=1;                  
                  _main_page[i].icon_list[t].fun();                 //触发回调
                }
                _main_page[i].icon_list[t].flag=1;
                touch_click_f = 1;                                  // VIEW_ICON 中的图标触发选中  
                win_refresh|=0x1;                                   // 标记清除选中需要刷新一次
              }else
              {
                _main_page[i].icon_list[t].flag=0;                  //将 VIEW_ICON 没有选择的标志清除
              }
            }
          }
          
          // 确定 ICON_BAR 哪个图标被选中
          for(t=0;t<ICON_BAR_ICON_NUM_X;t++) {        //图标号
            temp=icon_bar_list[t].icon_x+ICON_BAR_X;
            temp1=icon_bar_list[t].icon_y+ICON_BAR_Y;
            if(touch_click_f == 0
            && touch_click_x-temp < icon_bar_list[t].icon_xsize 
            && touch_click_y-temp1 < icon_bar_list[t].icon_ysize 
            && touch_click_x > temp
            && touch_click_y > temp1 )
            {
              /*行为：双击 图标*/
              if(icon_bar_list[t].flag==1){             
                double_click=1;  
                icon_bar_list[t].fun();     //触发回调
              }
              icon_bar_list[t].flag=1;
              touch_click_f = 2;                      // ICON_BAR 中的图标触发选中  
              win_refresh|=0x2;                       // 标记清除选中需要刷新一次      
            }else
            {
              icon_bar_list[t].flag=0;                //将 ICON_BAR 没有选择的标志清除
            }
          }
          
          // 什么都没有点
          if(touch_click_f!=1 && touch_click_f!=2){   //表示什么都没有点击
            WM_InvalidateWindow(pMsg->hWin);
            WM_SendMessageNoPara(icon_bar, MSG_WIN_INVAILD);   //发送到icon_bar ，刷新页面
            touch_click_f=3;                          // 都没有点到
          }
        } 
      }
    }
    else    
    {    
      move_touch_c=0;
    }   
    
    //用于解锁后防止滑动屏幕
    if(pState.Pressed==0){   
      move_touch_f=1;          // 记忆没有发生触摸
      touch_click_f = 0;
    }

    /* 行为：更改页面目标值 */
    if(move_touch_f==3 && abs(move_touch_c)>VIEW_ICON_XSIZE/4 && page_stability_f==1){
      if(move_touch_c<0 && c_page < MAIN_PAGE_NUM-1)  //切换下一页
      {
        scr_offset_o=scr_offset_o-VIEW_ICON_XSIZE; 
        page_stability_f=0;
        c_page++;
      }else if(move_touch_c>0 && c_page>0){       //切换上一页
        scr_offset_o=scr_offset_o+VIEW_ICON_XSIZE; 
        page_stability_f=0;
        c_page--;
      }
    }

    /*行为：自动定位主页*/
    if( move_touch_f==1 && scr_offset_o>scr_offset_c ){
      if((scr_offset_o-scr_offset_c)<VIEW_ICON_POSITIONING_VALUE)
        scr_offset_c=scr_offset_o;      //防止无法准确到达scr_offset_o值
      else
        scr_offset_c=scr_offset_c+VIEW_ICON_POSITIONING_VALUE;
    }else if( move_touch_f==1 && scr_offset_o<scr_offset_c ){
      if((scr_offset_c-scr_offset_o)<VIEW_ICON_POSITIONING_VALUE)
        scr_offset_c=scr_offset_o;      //防止无法准确到达scr_offset_o值
      else
        scr_offset_c=scr_offset_c-VIEW_ICON_POSITIONING_VALUE;
    }
    //页面稳定
    if(scr_offset_o==scr_offset_c)page_stability_f=1;
    
//    xprintf("move_touch_f:%d\r\n",move_touch_f);
//    temp1=xtime();
//    xprintf("time:%d\r\n",temp1-temp);
    break;
    
  case WM_DELETE:
    init_all_mainpage(); 
    
    // 删除所有的内存设备
    for(i=0;i<MAIN_PAGE_NUM;i++){                   //页号
      for(t=0;t<_main_page[i].icon_num;t++) {       //图标号
        GUI_MEMDEV_Delete(_main_page[i].icon_list[t].men_handle);
      }
    }
    break;
 
  default:
    WM_DefaultProc(pMsg);
    break;
  }
}

static void iconbar_cbDialog(WM_MESSAGE * pMsg) 
{
//  WM_HWIN hItem;
//  unsigned char i;
  unsigned char t;
  unsigned short temp;
#if(VIEW_DEBUG==1)
  long ram;
#endif  
  switch (pMsg->MsgId) {
  case WM_CREATE:   
    for(t=0;t<GUI_COUNTOF(icon_bar_list);t++) {       //图标号
      /*图标区域定位*/
      icon_bar_list[t].icon_xsize=(ICON_BAR_XSIZE-(ICON_BAR_ICON_NUM_X-1)*ICON_BAR_MIDDLE_INTERVAL-2*ICON_BAR_OUTSIDE_INTERVAL)/ICON_BAR_ICON_NUM_X;
      icon_bar_list[t].icon_ysize=(ICON_BAR_YSIZE-(ICON_BAR_ICON_NUM_Y+1)*ICON_BAR_Y_INTERVAL)/ICON_BAR_ICON_NUM_Y;
      temp=t%ICON_BAR_ICON_NUM_X;                  //所在行
      //图标区域的左上角起点X坐标
      icon_bar_list[t].icon_x=ICON_BAR_OUTSIDE_INTERVAL+ temp*ICON_BAR_MIDDLE_INTERVAL+temp*icon_bar_list[t].icon_xsize;

      temp=t/ICON_BAR_ICON_NUM_X;                //所在列
      icon_bar_list[t].icon_y=(temp+1)*ICON_BAR_Y_INTERVAL+temp*icon_bar_list[t].icon_ysize;
      //计算尺寸
      icon_bar_list[t].text_y=icon_bar_list[t].icon_y+
          icon_bar_list[t].icon_ysize-
          _main_page[0].pFont->YSize-ICON_BAR_TEXT_EDGE_SIZE;
      
      icon_bar_list[t].bitmap_xsize=icon_bar_list[t].icon_xsize;
      icon_bar_list[t].bitmap_ysize=icon_bar_list[t].text_y-icon_bar_list[t].icon_y;
      
      //文本区域的中心点起点X坐标,由icon_x计算
      icon_bar_list[t].text_c_x=(icon_bar_list[t].icon_x+icon_bar_list[t].bitmap_xsize/2);
      icon_bar_list[t].text_h_y=icon_bar_list[t].text_y+ICON_BAR_TEXT_EDGE_SIZE+ICON_BAR_TEXT_OFFSET;
      
      //绘制位图比例和选边
      if(icon_bar_list[t].bitmap_xsize>icon_bar_list[t].bitmap_ysize){
        //以Y尺寸绘图,y为短边
        temp=(icon_bar_list[t].bitmap_xsize - icon_bar_list[t].bitmap_ysize)/2;       //X方向多余部分，绘制正方形图标
        //位图区域的左上角起点X坐标,由icon_x计算
        icon_bar_list[t].bitmap_x=icon_bar_list[t].icon_x+temp;
        icon_bar_list[t].bitmap_y=icon_bar_list[t].icon_y;
        icon_bar_list[t].bitmap_rate=
          (float)icon_bar_list[t].bitmap_ysize/icon_bar_list[t].pBitmap->XSize;   //缩放图标比例
        icon_bar_list[t].bitmap_size=icon_bar_list[t].bitmap_ysize;
      }else{
        //以x尺寸绘图,x为短边
        temp=(icon_bar_list[t].bitmap_ysize - icon_bar_list[t].bitmap_xsize)/2;  
        //位图区域的左上角起点X坐标,由icon_x计算
        icon_bar_list[t].bitmap_x=icon_bar_list[t].icon_x;
        icon_bar_list[t].bitmap_y=icon_bar_list[t].icon_y+temp;
        icon_bar_list[t].bitmap_rate=
          (float)icon_bar_list[t].bitmap_xsize/icon_bar_list[t].pBitmap->XSize;   //缩放图标比例 
        icon_bar_list[t].bitmap_size=icon_bar_list[t].bitmap_xsize;
      }  
      
      /*创建内存设备*/    
      //内存设备区域的左上角起点X坐标  ,由icon_x计算    
      //这里使用的内存创建后没有主动释放
       icon_bar_list[t].men_handle=GUI_MEMDEV_CreateFixed(icon_bar_list[t].bitmap_x, icon_bar_list[t].bitmap_y,
      icon_bar_list[t].pBitmap->XSize, icon_bar_list[t].pBitmap->YSize,
      GUI_MEMDEV_HASTRANS, GUI_MEMDEV_APILIST_16, GUICC_M565);
      //绘制位图
      GUI_MEMDEV_Select(icon_bar_list[t].men_handle);
      GUI_DrawBitmap(icon_bar_list[t].pBitmap, 
      icon_bar_list[t].bitmap_x,
      icon_bar_list[t].bitmap_y);   
    }

    //提示此时生成位图的正方形边长
    //对齐到位图区域中心，使用图片1的，所以要保证图标大小一致，否则其他图标位置错误
    t=0;
    icon_bar_bp_offset=-(icon_bar_list[t].pBitmap->XSize-icon_bar_list[t].bitmap_size)/2+1;
    
      xprintf("icon_bar bitmap_size:%d\r\n",icon_bar_list[t].bitmap_size);
//      ram=GUI_ALLOC_GetNumFreeBytes();      //获取GUI剩余内存空间
//      xprintf("icon_bar GUI_Free_ram is %d\r\n",ram);
      
    //重新指定LCD输出
    GUI_MEMDEV_Select(0);
#if(VIEW_DEBUG==1)
    ram=GUI_ALLOC_GetNumFreeBytes();      //获取GUI剩余内存空间
    xprintf("GUI_Free_ram is %d\r\n",ram);  
#endif   

    break;
  
  case WM_PAINT:
    GUI_SetBkColor(ICON_BAR_BK_COLOR);        
    GUI_Clear();
  
#if(VIEW_DEBUG==1)
    debug_icon_bar();
#endif
    //绘制图标区域
    for(t=0;t<ICON_BAR_ICON_NUM_X;t++) {       //图标号
      //绘制被选择背景
      if(icon_bar_list[t].flag==1){
        GUI_SetColor(ICON_SELECTED_COLOR);
        GUI_FillRect(icon_bar_list[t].icon_x-ICON_BAR_EDGE_SIZE,
        icon_bar_list[t].icon_y-ICON_BAR_EDGE_SIZE,
        icon_bar_list[t].icon_x+icon_bar_list[t].icon_xsize+ICON_BAR_EDGE_SIZE,
        icon_bar_list[t].icon_y+icon_bar_list[t].icon_ysize+ICON_BAR_EDGE_SIZE);
      }
      
      //绘制图标区域      
      GUI_MEMDEV_WriteAt(icon_bar_list[t].men_handle,
      icon_bar_list[t].bitmap_x+icon_bar_bp_offset
      ,icon_bar_list[t].bitmap_y+icon_bar_bp_offset+ICON_BAR_Y);
      
      //绘制文本区域
      GUI_SetColor(GUI_BLACK);
      GUI_SetTextMode(GUI_TM_TRANS);          //透明背景
      GUI_DispStringHCenterAt(icon_bar_list[t].pText,icon_bar_list[t].text_c_x, 
      icon_bar_list[t].text_h_y);
    }
//    xprintf("icon_bar_refresh\r\n");
    break;
    
  case MSG_WIN_INVAILD:
    WM_InvalidateWindow(pMsg->hWin);  
    break;
  
  case WM_DELETE:
    init_all_mainpage(); 
    
    // 删除所有的内存设备
    for(t=0;t<GUI_COUNTOF(icon_bar_list);t++) {       //图标号
        GUI_MEMDEV_Delete(icon_bar_list[t].men_handle);
    }
    break;
    
  default:
    WM_DefaultProc(pMsg);
    break;
  }
}

/*********************************************************************
*
*       Createwin_mainpage
*/
WM_HWIN Createwin_mainpage(void);
WM_HWIN Createwin_mainpage(void) {
  WM_HWIN win[WIN_MAX_NUM]={0};
  
  //初始化主屏幕参数
  init_all_mainpage();                  
  /*****创建VIEW ICON区域*****/
  win[0]=WM_CreateWindowAsChild(VIEW_ICON_X, VIEW_ICON_Y, VIEW_ICON_XSIZE, VIEW_ICON_YSIZE,
  WM_HBKWIN, WM_CF_SHOW, viewicon_cbDialog, 0);
  //创建VIEW ICON定时器
  WM_CreateTimer(win[0], TIMER_0, VIEW_ICON_REFRESH_RATE, 0);

//  /*****创建ICON BAR区域*****/
  win[1]=WM_CreateWindowAsChild(ICON_BAR_X, ICON_BAR_Y, ICON_BAR_XSIZE, ICON_BAR_YSIZE,
  WM_HBKWIN, WM_CF_SHOW, iconbar_cbDialog, 0);
  
  icon_view = win[0];
  icon_bar = win[1];
  switch_win(win,MIAN_PAGE_WIN_ID);
  return win[0];
}


#define TIPS_WIN_XSIZE    150
#define TIPS_WIN_YSIZE    120
#define TIPS_WIN_X        (LCD_xsize-TIPS_WIN_XSIZE)/2
#define TIPS_WIN_Y        ((LCD_ysize-TIPS_WIN_YSIZE)/2-STATUS_BAR_HEIGHT)

#define TIPS_BUTTON_XSIZE  50
#define TIPS_BUTTON_YSIZE  25    
#define TIPS_BUTTON_X  ((TIPS_WIN_XSIZE-TIPS_BUTTON_XSIZE)/2)
#define TIPS_BUTTON_Y  (int)(TIPS_WIN_YSIZE * 0.65f)
#define TIPS_BUTTON_FONT   GUI_FONT_8X12_ASCII

#define TIPS_TEXT_XSIZE  (TIPS_WIN_XSIZE-20)
#define TIPS_TEXT_YSIZE  (TIPS_WIN_YSIZE-TIPS_BUTTON_YSIZE-60)    //不要覆盖到按钮窗口
#define TIPS_TEXT_X  (TIPS_WIN_XSIZE-TIPS_TEXT_XSIZE)/2
#define TIPS_TEXT_Y  (int)(TIPS_WIN_YSIZE * 0.30f)
#define TIPS_TEXT_TEXT   GUI_FONT_8X12_ASCII

#if(VIEW_DEBUG==1)
static void debug_view_region(void)
{
  //绘制窗口区域   
  GUI_SetColor(GUI_RED);        
  GUI_DrawRect(0,0,
    0+TIPS_WIN_XSIZE-1, 
    0+TIPS_WIN_YSIZE-1);
  
  //绘制文本区域   
  GUI_SetColor(GUI_WHITE);        
  GUI_DrawRect(TIPS_TEXT_X, TIPS_TEXT_Y, 
    TIPS_TEXT_X+TIPS_TEXT_XSIZE, 
    TIPS_TEXT_Y+TIPS_TEXT_YSIZE);

  //绘制按钮区域  
  GUI_SetColor(GUI_BLACK);       
  GUI_DrawRect(TIPS_BUTTON_X, TIPS_BUTTON_Y, 
   TIPS_BUTTON_X+TIPS_BUTTON_XSIZE, 
   TIPS_BUTTON_Y+TIPS_BUTTON_YSIZE); 
}
#endif

//创建提示窗口
static void Tips_cbDialog(WM_MESSAGE * pMsg) {
#if(VIEW_DEBUG==0)
  WM_HWIN hItem;
#endif
  int     NCode;
  int     Id;
//  long ram;

  switch (pMsg->MsgId) {
  case WM_CREATE:
    //显示框架
#if(VIEW_DEBUG==0)
    hItem=FRAMEWIN_CreateEx(0,0,TIPS_WIN_XSIZE,TIPS_WIN_YSIZE,pMsg->hWin,
    WM_CF_SHOW,0,ID_FRAMEWIN_0,"Tips",0);

    hItem=TEXT_CreateEx(TIPS_TEXT_X, TIPS_TEXT_Y,TIPS_TEXT_XSIZE, TIPS_TEXT_YSIZE,
    pMsg->hWin,WM_CF_SHOW,
    TEXT_CF_HCENTER|TEXT_CF_TOP, ID_TEXT_0, "Please set callback function");
    TEXT_SetWrapMode(hItem,GUI_WRAPMODE_WORD);
    WM_SetStayOnTop(hItem,1);                 //文本窗口始终在最上面

    hItem = BUTTON_CreateEx(TIPS_BUTTON_X,TIPS_BUTTON_Y,TIPS_BUTTON_XSIZE,TIPS_BUTTON_YSIZE,pMsg->hWin,WM_CF_SHOW,0,ID_BUTTON_0);
    WM_SetFocus(hItem);
    WM_SetStayOnTop(hItem,1);                 //按钮窗口始终在最上面
    BUTTON_SetFont(hItem, TIPS_BUTTON_FONT);
    BUTTON_SetText(hItem, "OK");
#endif
#if(VIEW_DEBUG==1)
    debug_view_region();
#endif
//    ram=GUI_ALLOC_GetNumFreeBytes();        //获取GUI剩余内存空间
//    xprintf("GUI_Free_ram is %d\r\n",ram);      
    break;
  
  case WM_NOTIFY_PARENT:
    Id    = WM_GetId(pMsg->hWinSrc);
    NCode = pMsg->Data.v;
    switch(Id) {
    case ID_BUTTON_0: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        WM_DeleteWindow(pMsg->hWin);
        break;
      case WM_NOTIFICATION_RELEASED:
        break;
      }
      break;
    }
    break;
    
  case WM_PAINT:
#if(VIEW_DEBUG==1)
    debug_view_region();
#endif
   break;
  
  case WM_DELETE:
    init_mainpage(); 
    if(_hLastFrame[0]!=0){
      WM_CreateTimer(icon_view, TIMER_0, VIEW_ICON_REFRESH_RATE, 0);
    }
    break;
  
  default:
    WM_DefaultProc(pMsg);
    break;
  }
}

WM_HWIN CreateTips(void) {

  icon_tips=WM_CreateWindowAsChild(TIPS_WIN_X, TIPS_WIN_Y, TIPS_WIN_XSIZE, TIPS_WIN_YSIZE,
  icon_view, WM_CF_SHOW|WM_CF_HASTRANS, Tips_cbDialog, 0);
  
  return icon_tips;
}
/*************************** End of file ****************************/
